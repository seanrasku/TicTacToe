1.
	I enjoyed this program the most out of the projects I've done so far,
mostly because I'm not too good at recursion, and this project really made
me work on my recursion skills. I had to watch videos, go to office hours,
and ask my father, who is a CS major to help me as well. However, I did
learn and figure out how to solve each identified problem myself, and that 
led to improvement in my ability to trace and debug recursive programs,
and that is why I enjoyed this project the most out of any project I've
coded so far in this class. The hardest part of the project for sure was
the double for loop, and figuring out why the recursion was not working for
me. I had to find why the values were messed up, and why the side was not
corresponding to the value in many cases. I finally realized that assigning 
the side to nextPlayer was what was messing up the code in the first place.
When I fixed this, part of the problem was solved, but I still needed to
figure out why the side was still messed up. I solved this by removing
the assignment of the HUMAN and COMPUTER to side before the for loop, and
chooseMove finally worked as expected. All the debugging and tracing led
to the improvement of my recursion skills for sure.

2.
	This means that the initial position takes the value at the branch of
the tree that has a 3 (Assuming the computer goes first) and goes down that
branch from there. The reason why it chose that value was because it was the
maximum of all the options available, because it gave the highest chance of
winning for the computer. The computer would win if it played all the right
moves. The initial position value for cs310.games.TicTacToe would also be whatever the
maximum value is for all of the children of the initial position board. If
it is the opponents win value, then there is no chance of winning. If it
is the player's win value, then the player has a chance at winning if they
play the right moves. Else, if it is a the value for a draw, then taking 
that move would result in a draw on the next move. 

3.
	An upper bound for the number of game states would be 4^9. There is a
maximum of 9 moves (5 + 3 + 1), and that would only occur if each player
only took 1 star for each turn for the entire game. The height of the tree
is also 9, because the longest possible game would simply be each side taking
1 star for each of their turns for the entire game. It would simply switch from
one player to the other for 9 levels down. The game state is 4 and not 3 because
it is necessary to also keep track of which player's turn it is. This is tracked
by the nextPlayer instance variable, which tracks who's turn is next, so the
current player's value (or turn) is the opposite value of nextPlayer. 

4.	
	When playing Sticks, it would be much more similar to cs310.games.Nim than Tic Tac Toe,
because an NxN board and symbols for each side wouldn't be needed. Instead, the
only instance variables that would be needed would be a single integer of value
7, similar to a slot in the heap instance variable in cs310.games.Nim. Because there is only
1 row, and not multiple rows of differing lengths, it does not need to be an
array of ints and instead only needs to be a single integer. The nextPlayer 
instance variable would also need to be present, as it would be necessary to 
keep track of who's turn is next as the levels of the game tree get lower and
lower, and on the way back up as well.